<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Platformer — Retro Runner</title>
<style>
  :root{--bg:#80c7ff;--ground:#6b4f2b;--block:#8b5e3c;--player:#ff5f57;--enemy:#333;--coin:#ffd24d}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(#bfeaff,var(--bg));}
  .wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:24px;box-sizing:border-box}
  .card{width:100%;max-width:960px;background:linear-gradient(180deg,rgba(255,255,255,0.2),rgba(255,255,255,0.06));border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(10,30,60,.18)}
  canvas{display:block;width:100%;height:540px;border-radius:10px;background:linear-gradient(#9fe0ff,#80c7ff);}
  .hud{display:flex;justify-content:space-between;margin-top:8px;color:#063048;font-weight:700}
  button{background:#063048;color:#fff;border:0;padding:6px 10px;border-radius:8px;cursor:pointer}
  .controls{font-size:13px;color:#01323a}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:800">Retro Runner — Platformer</div>
        <div>
          <button id="restart">Restart</button>
        </div>
      </div>
      <canvas id="game" width="960" height="540"></canvas>
      <div class="hud">
        <div id="score">Score: 0</div>
        <div class="controls">Controls: ← → to move, Space to jump, ↓ to drop through some platforms</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Tile size and map
  const TILE = 48;
  const GRAVITY = 0.9;
  const FRICTION = 0.85;

  // Level map: characters
  // '.' empty, '#' ground/block, '-' platform (one-way), 'C' coin, 'E' enemy, 'F' flag/finish
  const LEVEL = [
    '........................................................................................',
    '........................................................................................',
    '........................................................................................',
    '........................................................................................',
    '........................................................................................',
    '....................C.......................C...............C........................',
    '.............###..................#####..............................................',
    '..................---.....................---...............###......................',
    '.......C..................C.............C..........###...............................',
    '###########################..............###############################....#######..',
    '..............................................................................F.......',
  ];

  // convert to tile grid
  let cols = LEVEL[0].length; let rows = LEVEL.length;

  function tileAt(col,row){
    if(row<0 || row>=rows || col<0 || col>=cols) return '.';
    return LEVEL[row][col];
  }

  // Player
  const player = {
    x: TILE*2, y: TILE*(rows-3), w: 34, h: 44,
    vx:0, vy:0, speed:0.22, maxSpeed:5, jumping:false, grounded:false, alive:true,
    facing:1, score:0
  };

  // Enemies: spawn from map
  const enemies = [];
  const coins = [];
  let finish = null;

  function scanLevel(){
    enemies.length = 0; coins.length = 0; finish = null;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const ch = tileAt(c,r);
        const x = c*TILE + TILE/2; const y = r*TILE + TILE/2;
        if(ch==='E') enemies.push({x,y,w:36,h:36,vx:1.2,dir:1,alive:true});
        if(ch==='C') coins.push({x,y,w:20,h:20,collected:false});
        if(ch==='F') finish = {x:c*TILE + TILE/2, y:(r-1)*TILE, reached:false};
      }
    }
  }

  scanLevel();

  // Camera
  const camera = {x:0,y:0,w:W,h:H};

  // Input
  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code]=true; if(e.code==='Space') e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.code]=false; });

  document.getElementById('restart').addEventListener('click', restart);

  function restart(){
    player.x = TILE*2; player.y = TILE*(rows-3); player.vx=0; player.vy=0; player.alive=true; player.score=0;
    scanLevel();
  }

  function rectsOverlap(a,b){ return !(a.x + a.w/2 < b.x - b.w/2 || a.x - a.w/2 > b.x + b.w/2 || a.y + a.h/2 < b.y - b.h/2 || a.y - a.h/2 > b.y + b.h/2); }

  function update(dt){
    if(!player.alive) return;

    // horizontal input
    if(keys.ArrowLeft || keys.KeyA){ player.vx -= player.speed * dt * 60; player.facing = -1; }
    if(keys.ArrowRight || keys.KeyD){ player.vx += player.speed * dt * 60; player.facing = 1; }

    // limit speed
    player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));

    // jump
    if((keys.Space || keys.KeyW || keys.ArrowUp) && (player.grounded || (!player.jumping && player.vy>0 && player.vy<12))){
      if(player.grounded){ player.vy = -16; player.grounded = false; player.jumping = true; }
    }
    if(!(keys.Space || keys.KeyW || keys.ArrowUp)) player.jumping = false;

    // apply gravity
    player.vy += GRAVITY * dt * 60;

    // apply velocities
    player.x += player.vx * dt * 60;
    player.y += player.vy * dt * 60;

    // friction
    player.vx *= FRICTION;

    // collisions with tiles
    collisionWithTiles(player);

    // coins
    for(const c of coins){ if(!c.collected && rectsOverlap({x:player.x,y:player.y,w:player.w,h:player.h}, {x:c.x,y:c.y,w:c.w,h:c.h})){ c.collected=true; player.score += 10; } }

    // enemies
    for(const e of enemies){
      if(!e.alive) continue;
      // simple patrol
      e.x += e.vx * e.dir * dt * 60;
      // reverse on walls or edges
      if(collideWithWorld(e)) e.dir *= -1;
      // collision with player
      if(rectsOverlap({x:player.x,y:player.y,w:player.w,h:player.h},{x:e.x,y:e.y,w:e.w,h:e.h})){
        if(player.vy > 2){ // stomp
          e.alive = false; player.vy = -10; player.score += 50;
        } else { // die
          player.alive = false; setTimeout(()=>restart(),900);
        }
      }
    }

    // finish
    if(finish && player.x > finish.x){ finish.reached = true; player.alive = false; setTimeout(()=>alert('You win! Score: '+player.score),100); }

    // camera follow
    camera.x = player.x - camera.w/2; camera.y = player.y - camera.h/2;
    camera.x = Math.max(0, Math.min(camera.x, cols*TILE - camera.w));
    camera.y = Math.max(0, Math.min(camera.y, rows*TILE - camera.h));
  }

  function collideWithWorld(obj){
    // detect tile collisions for enemies; if touching ground or block return true
    const cx = Math.floor(obj.x / TILE); const cy = Math.floor(obj.y / TILE);
    // check surrounding tiles
    for(let r=cy-1;r<=cy+1;r++){
      for(let c=cx-1;c<=cx+1;c++){
        const ch = tileAt(c,r);
        if(ch==='.' || ch==='-' || ch==='C' || ch==='F') continue;
        const tileRect = {x:c*TILE + TILE/2, y:r*TILE + TILE/2, w:TILE, h:TILE};
        if(rectsOverlap({x:obj.x,y:obj.y,w:obj.w,h:obj.h}, tileRect)) return true;
      }
    }
    return false;
  }

  function collisionWithTiles(p){
    // calculate which tiles to check
    const left = Math.floor((p.x - p.w/2) / TILE);
    const right = Math.floor((p.x + p.w/2) / TILE);
    const top = Math.floor((p.y - p.h/2) / TILE);
    const bottom = Math.floor((p.y + p.h/2) / TILE);

    p.grounded = false;

    for(let r=top;r<=bottom;r++){
      for(let c=left;c<=right;c++){
        const ch = tileAt(c,r);
        if(ch === '.' || ch === 'C' || ch === 'F') continue;
        const tileX = c*TILE + TILE/2; const tileY = r*TILE + TILE/2;
        const tile = {x:tileX, y:tileY, w:TILE, h:TILE};

        if(ch === '-' ){
          // one-way platform: only collide when falling and above
          if(p.vy >= 0 && (p.y + p.h/2) - (tileY - TILE/2) <= 14){
            // collided with top
            if(p.y + p.h/2 > tileY - TILE/2){ p.y = tileY - TILE/2 - p.h/2; p.vy = 0; p.grounded = true; }
          }
          continue;
        }

        // solid block
        if(rectsOverlap(p, tile)){
          const overlapX = (p.w/2 + tile.w/2) - Math.abs(p.x - tile.x);
          const overlapY = (p.h/2 + tile.h/2) - Math.abs(p.y - tile.y);
          if(overlapX < overlapY){
            // resolve x
            if(p.x < tile.x) p.x -= overlapX; else p.x += overlapX;
            p.vx = 0;
          } else {
            // resolve y
            if(p.y < tile.y){ // hit from top
              p.y -= overlapY; p.vy = 0; p.grounded = true;
            } else {
              p.y += overlapY; p.vy = 0;
            }
          }
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // sky
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg');
    ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // draw tiles
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const ch = tileAt(c,r);
        const x = c*TILE, y = r*TILE;
        if(ch==='#'){
          // block
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--block');
          roundRectFill(ctx, x+4,y+4, TILE-8, TILE-8, 6);
        } else if(ch==='-'){
          ctx.fillStyle = '#5b3924'; ctx.fillRect(x+6, y+TILE/2 -4, TILE-12, 8);
        } else if(ch==='C'){
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--coin');
          ctx.beginPath(); ctx.arc(x+TILE/2, y+TILE/2, 10,0,Math.PI*2); ctx.fill();
          ctx.fillStyle='#ffecb3'; ctx.font='12px system-ui'; ctx.fillText('C', x+TILE/2-4, y+TILE/2+4);
        } else if(ch==='F'){
          ctx.fillStyle='#ffffff'; ctx.fillRect(x+TILE-6, y+TILE/2 -20, 6, 40);
          ctx.fillStyle='#ff3b3b'; ctx.beginPath(); ctx.moveTo(x+TILE-6,y+TILE/2-20); ctx.lineTo(x+TILE+20,y+TILE/2); ctx.lineTo(x+TILE-6,y+TILE/2+20); ctx.closePath(); ctx.fill();
        }
      }
    }

    // coins (collected handled)
    for(const c of coins){ if(!c.collected){ ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--coin'); ctx.beginPath(); ctx.arc(c.x, c.y, 10,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='10px system-ui'; ctx.fillText('o', c.x-3, c.y+3); } }

    // enemies
    for(const e of enemies){ if(!e.alive) continue; ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--enemy'); roundRectFill(ctx, e.x - e.w/2, e.y - e.h/2, e.w, e.h, 6); }

    // player
    if(player.alive){ drawPlayer(); } else { // dead: simple fade
      ctx.globalAlpha = 0.5; drawPlayer(); ctx.globalAlpha = 1; }

    ctx.restore();

    // HUD
    document.getElementById('score').textContent = 'Score: ' + player.score;
  }

  function drawPlayer(){
    ctx.save(); ctx.translate(player.x, player.y);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.beginPath(); ctx.ellipse(0, player.h/2 - 6, player.w/2, 8, 0,0,Math.PI*2); ctx.fill();
    // body - rounded rectangle
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player');
    roundRectFill(ctx, -player.w/2, -player.h/2, player.w, player.h, 8);
    // eye
    ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(player.facing*6 - 6, -8, 4,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function roundRectFill(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); c.closePath(); c.fill(); }

  // game loop
  let last = performance.now();
  function loop(now){ const dt = Math.min(0.035, (now - last)/1000); last = now; update(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
